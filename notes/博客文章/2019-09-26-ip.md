---
layout: post
title: "分割平衡字符串"
date: 2019-09-26 18:15:06 
description: "贪心算法"
tag: LeetCode
---

## 题目
在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。
给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

返回可以通过分割得到的平衡字符串的最大数量。

示例 1：
```java
输入：s = "RLRRLLRLRL"
输出：4
```
解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。

示例 2：
```java
输入：s = "RLLLLRRRLR"
输出：3
```
解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。

示例 3：
```java
输入：s = "LLLLRRRR"
输出：1
```
解释：s 只能保持原样 "LLLLRRRR".
 

提示：

* 1 <= s.length <= 1000
* s[i] = 'L' 或 'R'

## 解题
使用对消的思路。从左到右遍历, 根据题意，左边的 'L' 或 'R' 与右边的 'L' 或 'R' 相等。可以根据这个条件进行消除。
```java
class Solution {
    public int balancedStringSplit(String s) {
        int a = 0;
        int b = 0;
        for (char c : s.toCharArray()) {
            if (c == 'L') a++;
            else if (c == 'R') a--;
            // 每次对消成功 则生成一个平衡子串
            if (a == 0) b++;
        }
        return b;
    }
}
```
体现的贪心算法，描述说是：贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

在这里理解应该是，对消之前不影响对消之后的结果。


<br>

转载请注明：[sixkery的博客](http://sixkery.github.io) » [点击阅读原文](http://sixkery.github.io/201/09/ip/)